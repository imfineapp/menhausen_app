# Варианты шифрования премиум-статуса в localStorage

## Цели

1. **Защита от подделки**: Сложно сгенерировать валидные зашифрованные значения локально
2. **Уникальность**: Для каждого пользователя уникальный ключ шифрования
3. **Воспроизводимость**: Ключ можно получить только при доступе к Supabase
4. **Простота расшифровки**: Легко расшифровывать при наличии ключа
5. **Хранение**: Все значения `user-premium-*` хранятся только в зашифрованном виде

## Варианты реализации

### Вариант 1: Симметричное шифрование с ключом из Supabase

**Принцип:**
- Supabase генерирует уникальный ключ шифрования для каждого пользователя
- Ключ хранится в таблице `users` (например, `encryption_key`)
- Ключ передается через `get-user-data` вместе с премиум-статусом
- На клиенте используется AES-GCM или AES-CBC для шифрования/расшифровки

**Плюсы:**
- Простая реализация
- Быстрое шифрование/расшифровка
- Ключ можно ротировать через Supabase
- Полный контроль на сервере

**Минусы:**
- Ключ передается по сети (нужна защита через HTTPS/JWT)
- Если ключ скомпрометирован, все данные расшифровываются
- Требует хранения ключа в БД

**Безопасность:**
- ⭐⭐⭐⭐ (хорошая, если ключ защищен)

---

### Вариант 2: Асимметричное шифрование (RSA/OAEP)

**Принцип:**
- Supabase генерирует пару ключей (публичный/приватный) для каждого пользователя
- Публичный ключ передается клиенту через `get-user-data`
- Клиент шифрует данные публичным ключом
- Расшифровка происходит на сервере при синхронизации

**Плюсы:**
- Публичный ключ можно передавать открыто
- Высокая безопасность
- Невозможно расшифровать без приватного ключа

**Минусы:**
- Расшифровка только на сервере (не подходит для офлайн-режима)
- Медленнее симметричного шифрования
- Больший размер зашифрованных данных
- Сложнее реализация

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная, но не подходит для офлайн)

---

### Вариант 3: HMAC + Симметричное шифрование

**Принцип:**
- Supabase генерирует два ключа: `encryption_key` и `hmac_key`
- Данные шифруются `encryption_key` (AES)
- К зашифрованным данным добавляется HMAC подпись с `hmac_key`
- При расшифровке сначала проверяется HMAC, затем расшифровка

**Плюсы:**
- Двойная защита: шифрование + проверка подлинности
- Невозможно подделать без обоих ключей
- Можно проверить целостность без расшифровки

**Минусы:**
- Два ключа для управления
- Чуть больше кода

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная)

---

### Вариант 4: Ключ на основе Telegram User ID + Секрет из Supabase

**Принцип:**
- Используется комбинация: `telegram_user_id + secret_from_supabase`
- Секрет передается через `get-user-data` (например, `encryption_secret`)
- Ключ шифрования = `PBKDF2(telegram_user_id + secret, salt, iterations)`
- Salt может быть уникальным для пользователя или общим

**Плюсы:**
- Ключ уникален для каждого пользователя
- Не нужно хранить полный ключ в БД (только секрет)
- Можно использовать стандартные алгоритмы (PBKDF2, Argon2)

**Минусы:**
- Секрет все равно передается по сети
- Если секрет скомпрометирован, можно вычислить ключ для любого пользователя

**Безопасность:**
- ⭐⭐⭐ (средняя, зависит от защиты секрета)

---

### Вариант 5: Временные токены от Supabase

**Принцип:**
- Supabase выдает временный токен (JWT) с премиум-статусом
- Токен содержит зашифрованный премиум-статус и подпись
- Токен имеет срок действия (например, 24 часа)
- Клиент хранит токен в localStorage
- При истечении токена требуется обновление через Supabase

**Плюсы:**
- Автоматическое истечение (защита от старых данных)
- Можно включить дополнительную информацию в токен
- Стандартный формат (JWT)

**Минусы:**
- Требует периодического обновления
- В офлайн-режиме токен может истечь
- Нужно обрабатывать истечение токена

**Безопасность:**
- ⭐⭐⭐⭐ (хорошая, с автоматическим истечением)

---

### Вариант 6: Гибридный подход (Рекомендуемый)

**Принцип:**
- Комбинация вариантов 3 и 5:
  1. Supabase генерирует `encryption_key` и `hmac_key` для пользователя
  2. Ключи передаются через защищенный `get-user-data` (JWT)
  3. Данные шифруются AES-GCM с `encryption_key`
  4. Добавляется HMAC подпись с `hmac_key`
  5. Ключи можно ротировать через Supabase
  6. Опционально: временное истечение (например, 7 дней без обновления)

**Плюсы:**
- Максимальная безопасность
- Работает в офлайн-режиме
- Защита от подделки
- Можно ротировать ключи
- Гибкость в настройке

**Минусы:**
- Более сложная реализация
- Два ключа для управления

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная)

---

## Рекомендации по реализации

### Структура данных в localStorage

```
encrypted_premium_status: {
  data: "<encrypted_base64>",
  hmac: "<hmac_signature>",
  version: 1,  // для ротации ключей
  timestamp: 1234567890  // для проверки свежести
}
```

### Алгоритм шифрования

- **Шифрование**: AES-GCM-256 (аутентифицированное шифрование)
- **HMAC**: HMAC-SHA256
- **Ключи**: 256 бит каждый
- **IV/Nonce**: Генерируется случайно для каждого шифрования

### Поток работы

1. **При получении данных от Supabase:**
   - Получаем `encryption_key` и `hmac_key` через `get-user-data`
   - Расшифровываем существующие данные (если есть)
   - Шифруем новые данные с новыми ключами
   - Сохраняем в localStorage

2. **При чтении премиум-статуса:**
   - Читаем зашифрованные данные из localStorage
   - Если ключи есть в памяти - расшифровываем
   - Если ключей нет - запрашиваем через Supabase

3. **При обновлении премиум-статуса:**
   - Шифруем новые данные текущими ключами
   - Сохраняем в localStorage

### Безопасность ключей

- Ключи хранятся только в памяти (не в localStorage)
- Ключи получаются только через защищенный `get-user-data` (JWT)
- Ключи можно ротировать через Supabase (версионирование)
- При подозрении на компрометацию - ротация ключей

### Обработка ошибок

- Если расшифровка не удалась - считаем премиум недоступным
- Если HMAC не совпадает - считаем данные поддельными
- Если ключи отсутствуют - запрашиваем через Supabase
- Если Supabase недоступен - используем последние валидные данные (если есть)

---

## Сравнительная таблица

| Вариант | Безопасность | Офлайн | Сложность | Рекомендация |
|---------|--------------|--------|-----------|--------------|
| 1. Симметричное | ⭐⭐⭐⭐ | ✅ | Низкая | Хорошо |
| 2. Асимметричное | ⭐⭐⭐⭐⭐ | ❌ | Высокая | Не подходит |
| 3. HMAC + AES | ⭐⭐⭐⭐⭐ | ✅ | Средняя | Отлично |
| 4. PBKDF2 | ⭐⭐⭐ | ✅ | Средняя | Средне |
| 5. JWT токены | ⭐⭐⭐⭐ | ⚠️ | Средняя | Хорошо |
| 6. Гибридный | ⭐⭐⭐⭐⭐ | ✅ | Высокая | **Лучший** |

---

---

## Вариант 7: Шифрование на Supabase с проверкой через telegram_user_id

### Принцип

**Идея:** Использовать `telegram_user_id` как часть ключа шифрования, чтобы клиент мог расшифровать данные только если знает свой `telegram_user_id`, но не мог создать валидные данные без доступа к Supabase.

### Подварианты

#### 7.1: HMAC подпись с telegram_user_id

**Принцип:**
- Supabase создает HMAC подпись: `HMAC(secret_key + telegram_user_id, premium_data)`
- Клиент получает зашифрованные данные + HMAC подпись
- Клиент проверяет подпись используя свой `telegram_user_id` + секрет (переданный через Supabase)
- Если подпись валидна - данные достоверны

**Плюсы:**
- Проверка подлинности без расшифровки
- `telegram_user_id` является частью ключа
- Клиент не может создать валидную подпись без секрета

**Минусы:**
- Секрет все равно нужно передавать клиенту
- Данные не зашифрованы (только подписаны)

**Безопасность:**
- ⭐⭐⭐ (средняя, данные не зашифрованы)

---

#### 7.2: Шифрование с ключом = f(telegram_user_id + server_secret)

**Принцип:**
- Supabase шифрует данные используя ключ: `PBKDF2(telegram_user_id + server_secret, salt)`
- Клиент получает зашифрованные данные + salt
- Supabase передает клиенту производный ключ (вычисленный на сервере)
- Клиент расшифровывает используя переданный ключ
- Клиент не может самостоятельно вычислить ключ без `server_secret`

**Плюсы:**
- Данные зашифрованы
- Ключ уникален для каждого пользователя
- Клиент не может создать валидные данные без Supabase

**Минусы:**
- Ключ все равно передается по сети
- Если ключ скомпрометирован, данные расшифровываются

**Безопасность:**
- ⭐⭐⭐⭐ (хорошая, если ключ защищен)

---

#### 7.3: Асимметричное шифрование с ключом на основе telegram_user_id

**Принцип:**
- Supabase генерирует пару ключей на основе `telegram_user_id`: `generateKeyPair(telegram_user_id)`
- Публичный ключ используется для шифрования на Supabase
- Приватный ключ хранится на Supabase (не передается клиенту)
- Клиент получает зашифрованные данные
- Расшифровка происходит только на Supabase при запросе

**Плюсы:**
- Высокая безопасность
- Ключи уникальны для каждого пользователя
- Невозможно расшифровать без Supabase

**Минусы:**
- Не работает в офлайн-режиме
- Расшифровка только на сервере

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная, но не подходит для офлайн)

---

#### 7.4: Гибрид: Шифрование + HMAC с telegram_user_id (Рекомендуемый для этого подхода)

**Принцип:**
1. **На Supabase:**
   - Генерируется `encryption_key = PBKDF2(telegram_user_id + server_secret, salt, iterations)`
   - Генерируется `hmac_key = PBKDF2(telegram_user_id + server_secret_hmac, salt_hmac, iterations)`
   - Данные шифруются AES-GCM с `encryption_key`
   - Добавляется HMAC подпись: `HMAC(hmac_key, encrypted_data + telegram_user_id)`

2. **Передача клиенту:**
   - Зашифрованные данные
   - HMAC подпись
   - Salt значения
   - НЕ передаются ключи напрямую

3. **На клиенте:**
   - Клиент запрашивает производные ключи через защищенный API (JWT)
   - Supabase вычисляет ключи используя `telegram_user_id` из JWT
   - Ключи передаются клиенту (в памяти, не в localStorage)
   - Клиент расшифровывает и проверяет HMAC

**Плюсы:**
- Данные зашифрованы
- Проверка подлинности через HMAC
- Ключи уникальны для каждого пользователя
- Клиент не может создать валидные данные без Supabase
- Работает в офлайн-режиме (после получения ключей)

**Минусы:**
- Ключи все равно передаются (но только через защищенный API)
- Более сложная реализация

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная)

---

### Вариант 7.5: Проверка через telegram_user_id без передачи ключей

**Принцип:**
- Supabase создает токен: `JWT({premium: true, user_id: telegram_user_id}, secret_key)`
- Клиент получает токен
- Клиент проверяет токен используя публичный ключ или секрет (переданный через Supabase)
- Но проверка подписи требует знания секрета...

**Проблема:** Если секрет передается клиенту, то клиент может создать валидный токен.

**Решение:** Использовать асимметричную подпись (RS256):
- Supabase подписывает токен приватным ключом
- Клиент проверяет публичным ключом
- Клиент не может создать валидный токен без приватного ключа

**Плюсы:**
- Клиент не может подделать токен
- Проверка без обращения к серверу
- Стандартный формат (JWT)

**Минусы:**
- Публичный ключ нужно передавать клиенту
- Токен можно расшифровать (но не подделать)

**Безопасность:**
- ⭐⭐⭐⭐ (хорошая)

---

## Анализ подхода с telegram_user_id

### Можно ли использовать только telegram_user_id?

**Проблема:** Если ключ шифрования = только `telegram_user_id`, то:
- Любой может расшифровать данные, зная `telegram_user_id`
- Любой может создать валидные данные, зная `telegram_user_id`
- Нет защиты от подделки

**Вывод:** Только `telegram_user_id` недостаточно для безопасности.

### Решение: telegram_user_id + секрет

**Подход:** Использовать комбинацию `telegram_user_id + server_secret`:
- Ключ = `f(telegram_user_id, server_secret)`
- Клиент не знает `server_secret`, поэтому не может создать валидные данные
- Но для расшифровки нужен производный ключ от Supabase

### Варианты реализации

#### Вариант A: Ключ передается клиенту
- Supabase вычисляет ключ и передает клиенту
- Клиент расшифровывает локально
- **Проблема:** Ключ передается по сети

#### Вариант B: Расшифровка на сервере
- Клиент запрашивает расшифрованные данные
- Supabase расшифровывает и передает
- **Проблема:** Не работает офлайн

#### Вариант C: Производный ключ через защищенный API
- Клиент запрашивает производный ключ через JWT
- Supabase проверяет `telegram_user_id` из JWT
- Supabase вычисляет и передает ключ
- Клиент расшифровывает локально
- **Плюс:** Работает офлайн после получения ключа

---

## Рекомендация для подхода с telegram_user_id

**Вариант 7.4 (Гибрид)** - лучший баланс:

1. **Шифрование на Supabase:**
   ```javascript
   encryption_key = PBKDF2(telegram_user_id + server_secret, salt, 10000)
   hmac_key = PBKDF2(telegram_user_id + server_secret_hmac, salt_hmac, 10000)
   encrypted_data = AES-GCM-encrypt(premium_data, encryption_key)
   hmac = HMAC-SHA256(hmac_key, encrypted_data + telegram_user_id)
   ```

2. **Хранение в localStorage:**
   ```javascript
   {
     data: encrypted_data_base64,
     hmac: hmac_hex,
     salt: salt_base64,
     salt_hmac: salt_hmac_base64,
     version: 1
   }
   ```

3. **Получение ключей клиентом:**
   - Через защищенный `get-user-data` (JWT)
   - Supabase проверяет `telegram_user_id` из JWT
   - Supabase вычисляет ключи и передает клиенту
   - Ключи хранятся только в памяти

4. **Расшифровка на клиенте:**
   - Проверка HMAC используя `hmac_key`
   - Расшифровка используя `encryption_key`
   - Если HMAC не совпадает - данные поддельные

**Преимущества:**
- ✅ Данные зашифрованы
- ✅ Проверка подлинности через HMAC
- ✅ Ключи уникальны для каждого пользователя
- ✅ Клиент не может создать валидные данные без Supabase
- ✅ Работает офлайн после получения ключей
- ✅ `telegram_user_id` является частью ключа

---

## Вывод

**Рекомендуемый вариант: Гибридный подход (Вариант 6) или Вариант 7.4**

### Сравнение подходов:

| Подход | Использует telegram_user_id | Безопасность | Офлайн | Сложность |
|--------|----------------------------|--------------|--------|-----------|
| Вариант 6 (Гибридный) | ❌ | ⭐⭐⭐⭐⭐ | ✅ | Высокая |
| Вариант 7.4 (telegram_user_id + секрет) | ✅ | ⭐⭐⭐⭐⭐ | ✅ | Высокая |

**Вариант 7.4** имеет преимущество:
- `telegram_user_id` является частью ключа (более явная связь)
- Ключи можно пересчитать на сервере при необходимости
- Логически понятнее: ключ зависит от пользователя

**Оба варианта обеспечивают:**
- Максимальную защиту от подделки
- Работу в офлайн-режиме
- Возможность ротации ключей
- Проверку целостности данных

Дополнительно можно добавить:
- Временное истечение данных (опционально)
- Версионирование ключей для ротации
- Логирование попыток расшифровки для мониторинга

---

## Вариант 8: Подпись без шифрования (Проверка оффлайн без секрета)

### Цель

**Требования:**
- Данные хранятся открыто (не шифруются)
- Есть подпись для проверки подлинности
- Подпись можно проверить оффлайн БЕЗ получения секрета от Supabase
- Клиент не может создать валидную подпись локально

### Варианты реализации

#### Вариант 8.1: Асимметричная подпись (EdDSA/Ed25519) - Рекомендуемый

**Принцип:**
- Supabase генерирует пару ключей: приватный (на сервере) и публичный (передается клиенту)
- Supabase подписывает данные приватным ключом: `signature = Ed25519.sign(private_key, data)`
- Клиент получает данные + подпись + публичный ключ
- Клиент проверяет подпись публичным ключом: `Ed25519.verify(public_key, data, signature)`
- Проверка работает оффлайн, так как публичный ключ уже есть у клиента

**Плюсы:**
- ✅ Данные не шифруются (быстрый доступ)
- ✅ Проверка подлинности оффлайн
- ✅ Клиент не может подделать подпись (нет приватного ключа)
- ✅ Публичный ключ можно передать один раз или встроить в приложение
- ✅ Быстрая проверка подписи
- ✅ Компактные подписи (64 байта для Ed25519)

**Минусы:**
- Данные видны в открытом виде (но это не проблема для премиум-статуса)
- Нужно управлять парами ключей на сервере

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная)

**Реализация:**

1. **На Supabase (при создании/обновлении премиум-статуса):**
   ```javascript
   const data = JSON.stringify({ premium: true, plan: 'monthly', expiresAt: '...' });
   const signature = ed25519.sign(privateKey, data);
   // Сохраняем: data (открыто) + signature
   ```

2. **Передача клиенту:**
   ```javascript
   {
     data: { premium: true, plan: 'monthly', ... },
     signature: "<base64_signature>",
     publicKey: "<public_key_base64>", // можно передать один раз
     timestamp: 1234567890
   }
   ```

3. **Хранение в localStorage:**
   ```javascript
   {
     premium: true,
     plan: 'monthly',
     expiresAt: '...',
     signature: "<base64_signature>",
     publicKey: "<public_key_base64>", // или хранить отдельно
     timestamp: 1234567890
   }
   ```

4. **Проверка на клиенте (оффлайн):**
   ```javascript
   const data = JSON.stringify({ premium, plan, expiresAt });
   const isValid = ed25519.verify(publicKey, data, signature);
   if (!isValid) {
     // Подпись невалидна - данные поддельные
     return false;
   }
   ```

---

#### Вариант 8.2: Асимметричная подпись (RSA-PSS)

**Принцип:**
- Аналогично Ed25519, но использует RSA
- Supabase подписывает приватным ключом RSA
- Клиент проверяет публичным ключом RSA

**Плюсы:**
- ✅ Стандартный алгоритм (широко поддерживается)
- ✅ Проверка оффлайн
- ✅ Клиент не может подделать

**Минусы:**
- Больше размер подписи (256-512 байт в зависимости от размера ключа)
- Медленнее Ed25519
- Больше размер публичного ключа

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная)

---

#### Вариант 8.3: JWT с асимметричной подписью (RS256/ES256)

**Принцип:**
- Supabase создает JWT токен с премиум-статусом
- Токен подписывается приватным ключом (RS256 или ES256)
- Клиент получает токен + публичный ключ
- Клиент проверяет подпись токена публичным ключом

**Плюсы:**
- ✅ Стандартный формат (JWT)
- ✅ Можно включить дополнительную информацию (expires, issued_at)
- ✅ Проверка оффлайн
- ✅ Автоматическое истечение через `exp` claim

**Минусы:**
- Токен можно расшифровать (но не подделать)
- Больше размер данных

**Безопасность:**
- ⭐⭐⭐⭐⭐ (отличная)

**Пример структуры:**
```javascript
// JWT payload (расшифровывается, но не подделывается)
{
  premium: true,
  plan: 'monthly',
  expiresAt: '2026-12-31',
  userId: 123456789,
  iat: 1234567890,
  exp: 1735689600
}
```

---

#### Вариант 8.4: Подпись на основе telegram_user_id (НЕ рекомендуется)

**Принцип:**
- Использовать `telegram_user_id` как часть алгоритма подписи
- Но без секрета это небезопасно

**Проблема:**
- Если алгоритм известен, любой может создать валидную подпись
- Нет защиты от подделки

**Вывод:** ❌ Не подходит для безопасности

---

### Рекомендация: Вариант 8.1 (Ed25519)

**Почему Ed25519:**
- Самый быстрый алгоритм асимметричной подписи
- Компактные подписи (64 байта)
- Компактные ключи (32 байта приватный, 32 байта публичный)
- Высокая безопасность
- Широко поддерживается в современных библиотеках

### Структура данных в localStorage

```javascript
{
  // Данные премиума (открыто)
  premium: true,
  plan: 'monthly',
  expiresAt: '2026-12-31T23:59:59Z',
  purchasedAt: '2026-01-30T10:00:00Z',
  
  // Подпись для проверки подлинности
  signature: "base64_encoded_signature",
  
  // Публичный ключ (можно хранить отдельно или встроить в приложение)
  publicKey: "base64_encoded_public_key",
  
  // Метаданные
  version: 1,
  timestamp: 1234567890
}
```

### Поток работы

1. **При получении данных от Supabase:**
   - Supabase подписывает данные приватным ключом
   - Передает данные + подпись + публичный ключ
   - Клиент сохраняет в localStorage

2. **При чтении премиум-статуса (оффлайн):**
   - Читаем данные из localStorage
   - Проверяем подпись публичным ключом
   - Если подпись валидна - используем данные
   - Если подпись невалидна - считаем данные поддельными

3. **При обновлении премиум-статуса:**
   - Получаем новые данные от Supabase
   - Сохраняем с новой подписью

### Управление ключами

**Вариант A: Публичный ключ встроен в приложение**
- Публичный ключ компилируется в приложение
- Не нужно передавать каждый раз
- Минус: для ротации ключей нужен апдейт приложения

**Вариант B: Публичный ключ передается один раз**
- При первом запросе получаем публичный ключ
- Сохраняем в localStorage отдельно
- При ротации ключей получаем новый публичный ключ

**Вариант C: Публичный ключ передается с каждым ответом**
- Каждый ответ содержит публичный ключ
- Можно ротировать ключи без апдейта приложения
- Минус: больше трафика

**Рекомендация:** Вариант B (передается один раз, сохраняется)

### Ротация ключей

- Supabase может ротировать приватный ключ
- Новый публичный ключ передается клиенту
- Старые подписи остаются валидными до истечения данных
- Новые данные подписываются новым ключом

### Обработка ошибок

- Если подпись невалидна - считаем премиум недоступным
- Если публичный ключ отсутствует - запрашиваем через Supabase
- Если Supabase недоступен - используем последние валидные данные (если подпись валидна)

---

## Сравнение: Шифрование vs Подпись

| Аспект | Шифрование (Вариант 6/7) | Подпись (Вариант 8) |
|--------|-------------------------|---------------------|
| Данные скрыты | ✅ Да | ❌ Нет (открыто) |
| Проверка подлинности | ✅ Да (HMAC) | ✅ Да (Ed25519) |
| Проверка оффлайн | ✅ Да (нужен ключ) | ✅ Да (публичный ключ) |
| Нужен секрет для проверки | ✅ Да (HMAC ключ) | ❌ Нет (публичный ключ) |
| Клиент может подделать | ❌ Нет | ❌ Нет |
| Производительность | Медленнее (шифрование) | Быстрее (только проверка) |
| Размер данных | Больше (зашифровано) | Меньше (открыто) |
| Сложность | Выше | Ниже |

---

## Итоговая рекомендация

**Для вашего случая (подпись без шифрования, проверка оффлайн):**

✅ **Вариант 8.1 (Ed25519)** - лучший выбор:

1. Данные хранятся открыто (быстрый доступ)
2. Подпись Ed25519 для проверки подлинности
3. Публичный ключ передается один раз (можно встроить в приложение)
4. Проверка работает оффлайн без обращения к серверу
5. Клиент не может создать валидную подпись
6. Быстрая проверка подписи
7. Компактные подписи и ключи

**Реализация проще чем шифрование:**
- Не нужно управлять ключами шифрования
- Не нужно расшифровывать данные при чтении
- Только проверка подписи при чтении
- Данные доступны сразу

**Безопасность достаточна:**
- Премиум-статус не критичные данные для скрытия
- Главное - защита от подделки (обеспечивается подписью)
- Асимметричная подпись Ed25519 - криптографически стойкая
